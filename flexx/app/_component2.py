"""
Implementation of LocalComponent and ProxyComponent classes, which form
the basis for the PyComponent and JsComponent classes (and their proxies).
"""

import sys
import json
import threading

from ..pyscript import js_rename, window, JSString, undefined

from ..event import Component, loop, StringProp
from ..event._component import (with_metaclass, new_type, ComponentMeta,
                                finalize_component_class)

from ..event._property import Property
from ..event._emitter import EmitterDescriptor
from ..event._action import ActionDescriptor
from ..event._reaction import ReactionDescriptor
from ..event._js import create_js_component_class

from ._asset import get_mod_name
from . import logger


# The clientcore module is a PyScript module that forms the core of the
# client-side of Flexx. We import the serializer instance, and can use
# that name in both Python and JS. Of course, in JS it's just the
# corresponding instance from the module that's being used.
# By using something from clientcore in JS here, we make clientcore a
# dependency of the the current module.
# todo: replace this with bsdf
from ._clientcore import serializer

manager = None  # Set by __init__ to prevent circular dependencies

reprs = json.dumps  # todo: used?


def make_proxy_action(name):
    
    def proxy_action():
        self._proxy_action(name, arguments)
    return ActionDescriptor(proxy_action, name, '')


def get_component_classes():
    """ Get a list of all known PyComponent and JsComponent subclasses.
    """
    return [c for c in PyComponentMeta.CLASSES]


# Keep track of a stack of "active" components for use within context
# managers. We have one list for each thread. Note that we should limit
# its use to context managers, and execution should never be handed back
# to the Tornado event loop while inside a context.
_active_components_per_thread = {}  # dict of threadid -> list

def _get_active_components():
    """ Get list that represents the stack of "active" components.
    Each thread has its own stack. Should only be used directly inside
    a Component context manager.
    """
    # Get thread id
    if hasattr(threading, 'current_thread'):
        tid = id(threading.current_thread())
    else:  # pragma: no cover
        tid = id(threading.currentThread())
    # Get list of parents for this thread
    return _active_components_per_thread.setdefault(tid, [])


def get_active_components():
    """ Get a tuple of Component instances that represent the stack of "active"
    components. Each thread has its own stack. Also see get_active_component().
    """
    return tuple(_get_active_components())


def get_active_component():
    """ If the execution is now in a Component context manager, return the
    corresponding object, and None otherwise. Can be used by subclasses
    to implement parenting-like behaviour using the with-statement.
    """
    components = _get_active_components()
    if components:
        return components[-1]
    else:
        session = manager.get_default_session()
        if session is not None:
            return session.app


def meta_repr(cls):
    """ A repr function to provide some context on the purpose of a class.
    """
    if issubclass(cls, PyComponent):
        prefix = 'PyComponent class'
    elif issubclass(cls, PyComponent.JS):
        prefix = 'proxy PyComponent class for JS '
    elif issubclass(cls, JsComponent):
        prefix = 'proxy JsComponent class'
    elif issubclass(cls, JsComponent.JS):
        prefix = 'JsComponent class for JS'
    else:
        prefix = 'class'
    return "<%s '%s.%s'>" % (prefix, cls.__module__, cls.__name__)


# todo: can we get rid of event._component.new_type then?
class ComponentMetaJS(ComponentMeta):
    """ Meta class for autogenerated classes intended for JavaScript:
    Proxy PyComponent and local JsComponents.
    """
    
    __repr__ = meta_repr
    
    def __init__(self, name, *args):
        name = name.encode() if sys.version_info[0] == 2 else name
        return super().__init__(name, *args)


class AppComponentMeta(ComponentMeta):
    """ Meta class for PyComponent and JsComponent
    that generate a matching class for JS.
    """
    
    # Keep track of all subclasses
    CLASSES = []
    
    __repr__ = meta_repr
    
    def __init__(cls, cls_name, bases, dct):
        
        if issubclass(cls, LocalComponent):
            cls._make_js_proxy_class(cls_name, bases, dct)
        elif issubclass(cls, ProxyComponent):
            cls._make_js_local_class(cls_name, bases, dct)
        else:  # pragma: no cover
            raise TypeError('Expected class to inherit fro LocalComponent or ProxyComponent.')
        
        # Register this class. The classes in this list will be automatically
        # "pushed to JS" in a JIT fashion. We have to make sure that we include
        # the code for base classes not in this list, which we do in _get_js()
        # if not AppComponentMeta.CLASSES:
        #     AppComponentMeta.CLASSES.append(LocalComponent)
        #     AppComponentMeta.CLASSES.append(ProxyComponent)
        AppComponentMeta.CLASSES.append(cls)
    
    def _make_js_proxy_class(cls, cls_name, bases, dct):
        
        for c in bases:
           assert not issubclass(cls, ProxyComponent)
        
        OK_MAGICS = '__init__', '__json__', '__from_json__'
        
        # Fix inheritance for JS variant
        jsbases = [getattr(b, 'JS') for b in cls.__bases__ if hasattr(b, 'JS')]
        if not jsbases:
            jsbases.append(ProxyComponent)
        jsdict = {}
        
        # Copy properties from this class to the JS proxy class.
        # in Python 3.6 we iterate in the order in which the items are defined,
        for name, val in cls.__dict__.items():
            if name.startswith('__') and name.endswith('__'):
                continue
            elif isinstance(val, Property):
                jsdict[name] = val  # properties are the same
            elif isinstance(val, EmitterDescriptor):
                pass  # no emitters on the proxy side
            elif isinstance(val, ActionDescriptor):
                 jsdict[name] = make_proxy_action(name)  # proxy actions
            else:
                pass  # no reactions/functions/class attributes on the proxy side
        
        # Create JS class
        JS = ComponentMetaJS(cls_name, tuple(jsbases), jsdict)
        # Write __jsmodule__; an optimization for our module/asset system
        cls.__jsmodule__ = get_mod_name(sys.modules[cls.__module__])
        
        # Set JS, META, and CSS for this class
        cls.JS = JS
        cls.JS.CODE = cls._get_js()
        cls.CSS = cls.__dict__.get('CSS', '')
        
        # Drop into Component meta class
        ComponentMeta.__init__(cls, cls_name, bases, dct)

    def _make_js_local_class(cls, cls_name, bases, dct):
        
        for c in bases:
           assert not issubclass(cls, LocalComponent)
        
        OK_MAGICS = '__init__', '__json__', '__from_json__'
        
        # Fix inheritance for JS variant
        jsbases = [getattr(b, 'JS') for b in cls.__bases__ if hasattr(b, 'JS')]
        if not jsbases:
            jsbases.append(LocalComponent)
        jsdict = {}
        
        # Copy properties from this class to the JS proxy class.
        # in Python 3.6 we iterate in the order in which the items are defined,
        for name, val in list(cls.__dict__.items()):
            if name.startswith('__') and name.endswith('__'):
                continue
            elif isinstance(val, Property):
                jsdict[name] = val  # properties are the same
            elif isinstance(val, EmitterDescriptor):
                pass  # todo: create stub props for doc purposes
            elif isinstance(val, ActionDescriptor):
                # JS part gets the proper action, Py side gets a proxy action
                jsdict[name] = val
                setattr(cls, name, make_proxy_action(name))
            else:
                # Move attribute from the Py class to the JS calss
                jsdict[name] = val
                delattr(cls, name)
                dct.pop(name)  # is this necessary? 
        
        # Finalize classes
        JS = ComponentMetaJS(cls_name, tuple(jsbases), jsdict)
        # Write __jsmodule__; an optimization for our module/asset system
        cls.__jsmodule__ = get_mod_name(sys.modules[cls.__module__])
        
        # Set JS, META, and CSS for this class
        cls.JS = JS
        cls.JS.CODE = cls._get_js()
        cls.CSS = cls.__dict__.get('CSS', '')
        
        # Drop into Component meta class
        ComponentMeta.__init__(cls, cls_name, bases, dct)


    def _get_js(cls):
        """ Get source code for this class plus the meta info about the code.
        """
        # Since classes are defined in a module, we can safely name the classes
        # by their plain name. But flexx.classes.X remains the "official" 
        # namespace, so that things work easlily accross modules, and we can
        # even re-define classes (e.g. in the notebook).
        cls_name = cls.__name__
        base_class = cls.JS.mro()[1]
        base_class_name = '%s.prototype' % base_class.__name__
        code = []
        
        # Add this class
        c = create_js_component_class(cls.JS, cls_name, base_class_name)
        meta = c.meta
        code.append(c)
        # code.append(c.replace('var %s =' % cls_name,
        #                       'var %s = flexx.classes.%s =' % (cls_name, cls_name),
        #                       1))
        
        # Add JS version of Component when this is the Component class
        if base_class is LocalComponent:
            c = create_js_component_class(LocalComponent, 'LocalComponent', 'Component.prototype')
            # for k in ['vars_unknown', 'vars_global', 'std_functions', 'std_methods']:
                # meta[k].update(c.meta[k])
            # c = c.replace('var LocalComponent =',
            #               'var LocalComponent = flexx.classes.LocalComponent =', 1)
            code.insert(0, c)
            # code.insert(0, 'flexx.classes.Component = Component;')
        elif base_class is ProxyComponent:
            c = create_js_component_class(ProxyComponent, 'ProxyComponent', 'Component.prototype')
            for k in ['vars_unknown', 'vars_global', 'std_functions', 'std_methods']:
                meta[k].update(c.meta[k])
            # c = c.replace('var ProxyComponent =',
            #               'var ProxyComponent = flexx.classes.ProxyComponent =', 1)
            code.insert(0, c)
        
        # todo: cleanup or restore
        # if cls.JS.mro()[1] is Component:
        #     code.append('flexx.serializer.add_reviver("Flexx-Component",'
        #                 ' flexx.classes.Component.prototype.__from_json__);\n')
        # Return with meta info
        js = JSString('\n'.join(code))
        js.meta = meta
        return js


class LocalComponent(Component):
    """
    Base class for PyComponent in Python and JsComponent in JavaScript.
    """
    
    __jsmodule__ = __name__
    
    id = StringProp(doc='The id of this component')
    
    def __init__(self, *init_args, **kwargs):
        
        # Pop args that we need from the kwargs (because legacy Python does not
        # support keyword args after *args). Param "is_app" is not used here,
        # but we "take" the argument so it is not mistaken for a property value.
        session = kwargs.pop('session', None)
        kwargs.pop('is_app', None)
        
        # A local component can be associated with multiple sessions
        self._sessions = []
        if session is not None:
            self._sessions.append(session)
        # active_component = get_active_component()
        # if active_component is not None:
        #     self._sessions.extend(active_component._sessions)
        
        # Init Component, but delay initialization of handlers
        # We init after producing the JS command to create the corresponding
        # object, so that subsequent commands work ok
        super().__init__(_init_reactions=False, **kwargs)
        
        # The Component.__init__ sets _id, reset
        self._owner_id = 'unique id of Process that "owns" the component'
        self._id_value = self._id
        
        # Register this component with the session. Sets the id.
        # todo: uid + global count
        for session in self._sessions:
            session._register_component(self)
        
        # Get event types that we need to register that may come from other end
        known_event_types = self.__emitters__ + self.__properties__
        
        # # Further initialization of attributes
        # self.__event_types_js = event_types_js
        # self.__pending_events_from_js = []
        # self.__pending_props_from_js = []
        
        # # Get initial event connections
        # event_types_local = []
        # for reaction_name in self.__reactions__:
        #     descriptor = getattr(self.__class__, reaction_name)
        #     event_types_local.extend(descriptor.local_connection_strings)
        #     
        # Make JS-side events known
        for name in known_event_types:
            self._Component__handlers.setdefault(name, [])
        
        # Initialize the component further, e.g. Widgets can create
        # subwidgets etc. This is done here, at the point where the
        # properties are initialized, but the handlers not yet.
        with self:
            self.init(*init_args)
        # self._session._exec('flexx.instances.%s.init();' % self._id)
        
        # Initialize reactions for Python and for JS. Done after init()
        # so that they can connect to newly created sub Component's.
        self._init_reactions()
        # self._session._exec('flexx.instances.%s._init_handlers();' % self._id)
        # todo: ? self._session.keep_alive(self)
    
    def __repr__(self):
        clsname = self.__class__.__name__
        return "<%s object '%s' at 0x%s>" % (clsname, self._id, id(self))
    
    def __json__(self):
        return {'__type__': 'Flexx-Component',
                'session_id': self.session.id,
                'id': self.id}
    
    # @staticmethod
    # def __from_json__(dct):
    #     session = manager.get_session_by_id(dct['session_id'])
    #     return session.get_component_instance_by_id(dct['id'])
    
    # todo: oh dear, I suspect that the loop should handle this, or a class here
    def __enter__(self):
        # Note that __exit__ is guaranteed to be called, so there is
        # no need to use weak refs for items stored in active_components
        active_components = _get_active_components()
        active_components.append(self)
        loop.call_later(self.__check_not_active)
        return self
    
    def __exit__(self, type, value, traceback):
        active_components = _get_active_components()
        assert self is active_components.pop(-1)
    
    def init(self):
        """ Can be overloaded when creating a custom class to do
        initialization, such as creating sub components. This function is
        called with this object as a context manager (the default
        context is a stub).
        """
        pass
    
    def __check_not_active(self):
        return
        # active_components = _get_active_components()
        if self in active_components:
            raise RuntimeError('It seems that the event loop is processing '
                               'events while a Component is active. This has a '
                               'high risk on race conditions.')
    

class ProxyComponent(Component):
    """
    Base class for JSComponent in Python and PyComponent in JavaScript.
    
    We keep a pool of these, and only really remove when disposed from JS, or
    when the session closes. Or not? What if a JS component is deleted without
    having been disposed?
    """
    
    __jsmodule__ = __name__
    
    def __init__(self):
        pass
        
        # # Instantiate JavaScript version of this class
        # clsname = 'flexx.classes.' + self.__class__.__name__
        # cmd = 'flexx.instances.%s = new %s(%s, %s, %s);' % (
        #         self._id, clsname, reprs(self._id),
        #         serializer.saves(event_types_py),
        #         serializer.saves(known_event_types_py))
        # self._session._exec(cmd)
    
    def _proxy_action(name, *args, **kwargs):
        print('proxy action', args, kwargs)
        # todo: send to other side over the ws

    def _mutate(self, *args, **kwargs):
        raise RuntimeError('Cannot mutate properties from a proxy class.')
    
    def meh(self):
        # todo: use something from serializer (i.e. clientcore module) to trigger it being pushed to JS
        serializer.saves(''),


# Apply proper inheritance for generated JS classes
# LocalComponent.JS = ProxyComponent
# ProxyComponent.JS = LocalComponent


class StubComponent(Component):
    """
    Base class for proxied PyComponents in Python and proxied JsComponents
    in JavaScript.
    """
    # todo: should this perhaps be a singleton?


class PyComponent(with_metaclass(AppComponentMeta, LocalComponent)):
    
    # the meta class will generate a PyComponent proxy class for JS
    pass


class JsComponent(with_metaclass(AppComponentMeta, ProxyComponent)):
    
    # the meta class will generate a JsComponent local class for JS
    # and move all props, actions, etc. to it
    pass
