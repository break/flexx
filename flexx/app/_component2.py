"""
Implementation of LocalComponent and ProxyComponent classes, which form
the basis for the PyComponent and JsComponent classes (and their proxies).
"""

import sys
import threading

from ..pyscript import js_rename, window, JSString, undefined

from ..event import Component, loop
from ..event._component import (with_metaclass, new_type, ComponentMeta,
                                finalize_component_class)

from ..event._property import Property
from ..event._emitter import EmitterDescriptor
from ..event._action import ActionDescriptor
from ..event._reaction import ReactionDescriptor
from ..event._js import JS_EVENT, create_js_component_class

from ._asset import get_mod_name
from . import logger


# The clientcore module is a PyScript module that forms the core of the
# client-side of Flexx. We import the serializer instance, and can use
# that name in both Python and JS. Of course, in JS it's just the
# corresponding instance from the module that's being used.
# By using something from clientcore in JS here, we make clientcore a
# dependency of the the current module.
# todo: replace this with bsdf
from ._clientcore import serializer


def make_proxy_action(name):
    
    def proxy_action():
        self._proxy_action(name, arguments)
    return ActionDescriptor(proxy_action, name, '')


def get_component_classes():
    """ Get a list of all known PyComponent and JsComponent subclasses.
    """
    # todo: only PyComponent or also JsComponent?
    return [c for c in PyComponentMeta.CLASSES if issubclass(c, PyComponent)]


# Keep track of a stack of "active" components for use within context
# managers. We have one list for each thread. Note that we should limit
# its use to context managers, and execution should never be handed back
# to the Tornado event loop while inside a context.
_active_components_per_thread = {}  # dict of threadid -> list

def _get_active_components():
    """ Get list that represents the stack of "active" components.
    Each thread has its own stack. Should only be used directly inside
    a Component context manager.
    """
    # Get thread id
    if hasattr(threading, 'current_thread'):
        tid = id(threading.current_thread())
    else:  # pragma: no cover
        tid = id(threading.currentThread())
    # Get list of parents for this thread
    return _active_components_per_thread.setdefault(tid, [])


def get_active_components():
    """ Get a tuple of Component instances that represent the stack of "active"
    components. Each thread has its own stack. Also see get_active_component().
    """
    return tuple(_get_active_components())


def get_active_component():
    """ If the execution is now in a Component context manager, return the
    corresponding object, and None otherwise. Can be used by subclasses
    to implement parenting-like behaviour using the with-statement.
    """
    components = _get_active_components()
    if components:
        return components[-1]
    else:
        session = manager.get_default_session()
        if session is not None:
            return session.app


def meta_repr(cls):
    """ A repr function to provide some context on the purpose of a class.
    """
    if issubclass(cls, PyComponent):
        extra = 'PyComponent'
    elif issubclass(cls, PyComponent.JS):
        extra = 'proxy PyComponent for JS '
    elif issubclass(cls, JsComponent):
        extra = 'proxy JsComponent'
    elif issubclass(cls, JsComponent.JS):
        extra = 'JsComponent for JS'
    else:
        extra = 'unknown'
    return "<class '%s.%s' (%s)>" % (cls.__module__, cls.__name__, extra)


# todo: inherit from ComponentMeta?
# todo: can we get rid of event._component.new_type then?
class ComponentMetaJS(ComponentMeta):
    """ Meta class for autogenerated classes intended for JavaScript:
    Proxy PyComponent and local JsComponents.
    """
    
    __repr__ = meta_repr
    
    def __init__(self, name, *args):
        name = name.encode() if sys.version_info[0] == 2 else name
        return super().__init__(name, *args)


class AppComponentMeta(ComponentMeta):
    """ Meta class for PyComponent and JsComponent
    that generate a matching class for JS.
    """
    
    # Keep track of all subclasses
    CLASSES = []
    
    __repr__ = meta_repr
    
    def __init__(cls, cls_name, bases, dct):
        
        if issubclass(cls, LocalComponent):
            cls._make_js_proxy_class(cls_name, bases, dct)
        elif issubclass(cls, ProxyComponent):
            cls._make_js_local_class(cls_name, bases, dct)
        else:  # pragma: no cover
            raise TypeError('Expected class to inherit fro LocalComponent or ProxyComponent.')
        
        # Register this class and make PyScript convert the name
        AppComponentMeta.CLASSES.append(cls)
    
    def _make_js_proxy_class(cls, cls_name, bases, dct):
        
        for c in bases:
           assert not issubclass(cls, ProxyComponent)
        
        OK_MAGICS = '__init__', '__json__', '__from_json__'
        
        # Implicit inheritance for JS "subclass"
        jsbases = [getattr(b, 'JS') for b in cls.__bases__ if hasattr(b, 'JS')]
        jsdict = {}
        
        # if 'JS' in cls.__dict__:
        #     if '__init__' in cls.JS.__dict__:
        #         JS.__init__ = cls.JS.__init__
        #     for name, val in cls.JS.__dict__.items():
        #         if not name.startswith('__'):
        #             bettername = name.replace('_JS__', '_' + cls.__name__ + '__')
        #             setattr(JS, bettername, val)
        #         elif name in OK_MAGICS:
        #             setattr(JS, name, val)
        
        # Copy properties from this class to the JS proxy class.
        # in Python 3.6 we iterate in the order in which the items are defined,
        for name, val in cls.__dict__.items():
            if name.startswith('__') and name.endswith('__'):
                continue
            elif isinstance(val, Property):
                 jsdict[name] = val  # properties are the same
            elif isinstance(val, EmitterDescriptor):
                pass  # no emitters on the proxy side
            elif isinstance(val, ActionDescriptor):
                 jsdict[name] = make_proxy_action(name)
            elif isinstance(val, ReactionDescriptor):
                pass  # no reactions on the proxy side
            elif callable(val):
                pass
            else:
                pass # todo: not here, but in JsComponentMeta!
                #setattr(cls.JS, name, val)
                #setattr(cls, name, val)
        
        # # Create stub emitters on main class (for docs on events)
        # for name, val in cls.JS.__dict__.items():
        #     if isinstance(val, Emitter) and not hasattr(cls, name):
        #         p = val.__class__(stub_emitter_func_py, name, val._func.__doc__)
        #         setattr(cls, name, p)
        
        # Finalize classes
        # todo: it looks like this happens twice because the metaclass inherits from ComponentMeta
        # finalize_component_class(JS)
        JS = ComponentMetaJS(cls_name, tuple(jsbases), jsdict)
        cls.JS = JS
        
        # Write __jsmodule__; an optimization for our module/asset system
        JS.__jsmodule__ = get_mod_name(sys.modules[cls.__module__])
        
        # Set JS, META, and CSS for this class
        cls.JS.CODE = _get_js(cls)
        cls.CSS = cls.__dict__.get('CSS', '')
        
        # Drop into Component meta class
        ComponentMeta.__init__(cls, cls_name, bases, dct)

    def _make_js_local_class(cls, cls_name, bases, dct):
        
        for c in bases:
           assert not issubclass(cls, LocalComponent)
        
        OK_MAGICS = '__init__', '__json__', '__from_json__'
        
        # Implicit inheritance for JS "subclass"
        jsbases = [getattr(b, 'JS') for b in cls.__bases__ if hasattr(b, 'JS')]
        jsdict = {}
        
        # if 'JS' in cls.__dict__:
        #     if '__init__' in cls.JS.__dict__:
        #         JS.__init__ = cls.JS.__init__
        #     for name, val in cls.JS.__dict__.items():
        #         if not name.startswith('__'):
        #             bettername = name.replace('_JS__', '_' + cls.__name__ + '__')
        #             setattr(JS, bettername, val)
        #         elif name in OK_MAGICS:
        #             setattr(JS, name, val)
        
        # Copy properties from this class to the JS proxy class.
        # in Python 3.6 we iterate in the order in which the items are defined,
        for name, val in list(cls.__dict__.items()):
            if name.startswith('__') and name.endswith('__'):
                continue
            elif isinstance(val, Property):
                jsdict[name] = val  # properties are the same
            elif isinstance(val, EmitterDescriptor):
                pass  # no emitters on the proxy side
            elif isinstance(val, ActionDescriptor):
                # JS part gets the proper action, Py side gets a proxy action
                jsdict[name] = val
                setattr(cls, name, make_proxy_action(name))
            else:
                # Move attribute from the Py class to the JS calss
                jsdict[name] = val
                delattr(cls, name)
                dct.pop(name)  # is this necessary? 
        
        # # Create stub emitters on main class (for docs on events)
        # for name, val in cls.JS.__dict__.items():
        #     if isinstance(val, Emitter) and not hasattr(cls, name):
        #         p = val.__class__(stub_emitter_func_py, name, val._func.__doc__)
        #         setattr(cls, name, p)
        
        # Finalize classes
        # todo: it looks like this happens twice because the metaclass inherits from ComponentMeta
        # finalize_component_class(JS)
        JS = ComponentMetaJS(cls_name, tuple(jsbases), jsdict)
        cls.JS = JS
        
        # Write __jsmodule__; an optimization for our module/asset system
        JS.__jsmodule__ = get_mod_name(sys.modules[cls.__module__])
        
        # Set JS, META, and CSS for this class
        cls.JS.CODE = _get_js(cls)
        cls.CSS = cls.__dict__.get('CSS', '')
        
        # Drop into Component meta class
        ComponentMeta.__init__(cls, cls_name, bases, dct)


def _get_js(cls):
    """ Get source code for this class plus the meta info about the code.
    """
    # Since classes are defined in a module, we can safely name the classes
    # by their plain name. But flexx.classes.X remains the "official" 
    # namespace, so that things work easlily accross modules, and we can
    # even re-define classes (e.g. in the notebook).
    cls_name = cls.__name__
    base_class = 'flexx.classes.%s.prototype' % cls.mro()[1].__name__
    code = []
    # Add JS version of Component when this is the Component class
    if cls.mro()[1] is Component:
        c = js_rename(JS_EVENT, 'Component', 'flexx.classes.Component')
        code.append(c)
    # Add this class
    c = create_js_component_class(cls.JS, cls_name, base_class)
    meta = c.meta
    code.append(c.replace('var %s =' % cls_name,
                          'var %s = flexx.classes.%s =' % (cls_name, cls_name),
                           1))
    if cls.mro()[1] is Component:
        code.append('flexx.serializer.add_reviver("Flexx-Component",'
                    ' flexx.classes.Component.prototype.__from_json__);\n')
    # Return with meta info
    js = JSString('\n'.join(code))
    js.meta = meta
    return js


class LocalComponent(Component):
    """
    Base class for PyComponent in Python and JsComponent in JavaScript.
    """
    
    def __init__(self, *init_args, **kwargs):
        
        # Pop args that we need from the kwargs (because legacy Python does not
        # support keyword args after *args). Param "is_app" is not used here,
        # but we "take" the argument so it is not mistaken for a property value.
        session = kwargs.pop('session', None)
        kwargs.pop('is_app', None)
        
        # Init session
        if False:
            if session is None:
                active_component = get_active_component()
                if active_component is not None:
                    session = active_component.session
            if session is None:
                raise RuntimeError('Cannot instantiate Component %s without a session'
                                % self.__class__.__name__)
            self._session = session
        
            # Register this component with the session. Sets the id.
            # todo: uid + global count
            session._register_component(self)
        
        # Get initial event connections
        event_types_local = []
        for reaction_name in self.__reactions__:
            descriptor = getattr(self.__class__, reaction_name)
            event_types_local.extend(descriptor.local_connection_strings)
        
        # Get event types that we need to register that may come from other end
        known_event_types = self.__emitters__ + self.__properties__
        
        # # Further initialization of attributes
        # self.__event_types_js = event_types_js
        # self.__pending_events_from_js = []
        # self.__pending_props_from_js = []
        
        
        # Init Component, but delay initialization of handlers
        # We init after producing the JS command to create the corresponding
        # object, so that subsequent commands work ok
        super().__init__(_init_reactions=False, **kwargs)
        
        # Make JS-side events known
        for name in known_event_types:
            self._Component__handlers.setdefault(name, [])
        
        # Initialize the component further, e.g. Widgets can create
        # subwidgets etc. This is done here, at the point where the
        # properties are initialized, but the handlers not yet.
        with self:
            self.init(*init_args)
        # self._session._exec('flexx.instances.%s.init();' % self._id)
        
        # Initialize reactions for Python and for JS. Done after init()
        # so that they can connect to newly created sub Component's.
        self._init_reactions()
        # self._session._exec('flexx.instances.%s._init_handlers();' % self._id)
        # todo: ? self._session.keep_alive(self)
    
    def __repr__(self):
        clsname = self.__class__.__name__
        return "<%s object '%s' at 0x%x>" % (clsname, self._id, id(self))
    
    def __json__(self):
        return {'__type__': 'Flexx-Component',
                'session_id': self.session.id,
                'id': self.id}
    
    @staticmethod
    def __from_json__(dct):
        session = manager.get_session_by_id(dct['session_id'])
        return session.get_component_instance_by_id(dct['id'])
    
    def __enter__(self):
        # Note that __exit__ is guaranteed to be called, so there is
        # no need to use weak refs for items stored in active_components
        active_components = _get_active_components()
        active_components.append(self)
        loop.call_later(self.__check_not_active)
        return self
    
    def __exit__(self, type, value, traceback):
        active_components = _get_active_components()
        assert self is active_components.pop(-1)
    
    def init(self):
        """ Can be overloaded when creating a custom class to do
        initialization, such as creating sub components. This function is
        called with this object as a context manager (the default
        context is a stub).
        """
        pass
    
    def __check_not_active(self):
        active_components = _get_active_components()
        if self in active_components:
            raise RuntimeError('It seems that the event loop is processing '
                               'events while a Component is active. This has a '
                               'high risk on race conditions.')
    

class ProxyComponent(Component):
    """
    Base class for JSComponent in Python and PyComponent in JavaScript.
    
    We keep a pool of these, and only really remove when disposed from JS, or
    when the session closes. Or not? What if a JS component is deleted without
    having been disposed?
    """
    
    def __init__(self):
        pass
        
        # # Instantiate JavaScript version of this class
        # clsname = 'flexx.classes.' + self.__class__.__name__
        # cmd = 'flexx.instances.%s = new %s(%s, %s, %s);' % (
        #         self._id, clsname, reprs(self._id),
        #         serializer.saves(event_types_py),
        #         serializer.saves(known_event_types_py))
        # self._session._exec(cmd)
    
    def _proxy_action(name, *args, **kwargs):
        print('proxy action', args, kwargs)
        # todo: send to other side over the ws

    def _mutate(self, *args, **kwargs):
        raise RuntimeError('Cannot mutate properties from a proxy class.')


# Apply proper inheritance for generated JS classes
LocalComponent.JS = ProxyComponent
ProxyComponent.JS = LocalComponent



class StubComponent(Component):
    """
    Base class for proxied PyComponents in Python and proxied JsComponents
    in JavaScript.
    """
    # todo: should this perhaps be a singleton?


class PyComponent(with_metaclass(AppComponentMeta, LocalComponent)):
    
    # the meta class will generate a PyComponent proxy class for JS
    pass


class JsComponent(with_metaclass(AppComponentMeta, ProxyComponent)):
    
    # the meta class will generate a JsComponent local class for JS
    # and move all props, actions, etc. to it
    pass
